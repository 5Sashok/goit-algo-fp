from typing import Dict, List, Tuple

items = {
    "pizza": {"cost": 50, "calories": 300},
    "hamburger": {"cost": 40, "calories": 250},
    "hot-dog": {"cost": 30, "calories": 200},
    "pepsi": {"cost": 10, "calories": 100},
    "cola": {"cost": 15, "calories": 220},
    "potato": {"cost": 25, "calories": 350},
}

def greedy_algorithm(items: Dict[str, Dict[str, int]], budget: int) -> Tuple[List[str], int, int]:
    """
    Жадібний вибір за максимальним співвідношенням калорії/ціна.
    Повертає: (список назв, загальна_ціна, загальні_калорії)
    """
    # відсортуємо за ratio ↓; при рівності — за калоріями ↓
    ranked = sorted(
        items.items(),
        key=lambda kv: (kv[1]["calories"] / kv[1]["cost"], kv[1]["calories"]),
        reverse=True,
    )
    chosen, cost_sum, cal_sum = [], 0, 0
    left = budget
    for name, props in ranked:
        c, cal = props["cost"], props["calories"]
        if c <= left:
            chosen.append(name)
            cost_sum += c
            cal_sum += cal
            left -= c
    return chosen, cost_sum, cal_sum


def dynamic_programming(items: Dict[str, Dict[str, int]], budget: int) -> Tuple[List[str], int, int]:
    """
    Класичний 0/1 knapsack.
    Максимізує калорійність при обмеженні бюджету.
    Повертає: (оптимальний_набір, загальна_ціна, загальні_калорії)
    """
    names = list(items.keys())
    costs = [items[n]["cost"] for n in names]
    calories = [items[n]["calories"] for n in names]
    n = len(names)
    W = int(budget)

    # dp[i][w] = макс. калорії, використовуючи перші i предметів при бюджеті w
    dp = [[0]*(W+1) for _ in range(n+1)]

    for i in range(1, n+1):
        w_i, v_i = costs[i-1], calories[i-1]
        for w in range(W+1):
            best = dp[i-1][w]  # не беремо i-й
            if w_i <= w:
                best = max(best, dp[i-1][w - w_i] + v_i)  # беремо i-й
            dp[i][w] = best

    # Відновлення вибору
    chosen = []
    w = W
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i-1][w]:
            chosen.append(names[i-1])
            w -= costs[i-1]
    chosen.reverse()

    total_cost = sum(items[x]["cost"] for x in chosen)
    total_cal = sum(items[x]["calories"] for x in chosen)
    return chosen, total_cost, total_cal


# ---------------- Демонстрація ----------------
if __name__ == "__main__":
    budget = 100

    g_items, g_cost, g_cal = greedy_algorithm(items, budget)
    print("Жадібний підхід:")
    print("  вибір:", g_items)
    print(f"  вартість={g_cost}, калорії={g_cal}")

    d_items, d_cost, d_cal = dynamic_programming(items, budget)
    print("\nДинамічне програмування (оптимально):")
    print("  вибір:", d_items)
    print(f"  вартість={d_cost}, калорії={d_cal}")
